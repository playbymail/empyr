// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: queries.sql

package sqlc

import (
	"context"
	"database/sql"
)

const createDeposit = `-- name: CreateDeposit :one
INSERT INTO deposits (planet_id, deposit_no, kind, yield_pct, initial_qty, remaining_qty)
VALUES (?1, ?2, ?3, ?4, ?5, ?6)
RETURNING id
`

type CreateDepositParams struct {
	PlanetID     int64
	DepositNo    int64
	Kind         string
	YieldPct     int64
	InitialQty   int64
	RemainingQty int64
}

// CreateDeposit creates a new deposit.
func (q *Queries) CreateDeposit(ctx context.Context, arg CreateDepositParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, createDeposit,
		arg.PlanetID,
		arg.DepositNo,
		arg.Kind,
		arg.YieldPct,
		arg.InitialQty,
		arg.RemainingQty,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createEmpire = `-- name: CreateEmpire :one
INSERT INTO empires (game_id, empire_no, name, handle, home_system_id, home_star_id, home_orbit_id, home_planet_id)
VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8)
RETURNING id
`

type CreateEmpireParams struct {
	GameID       int64
	EmpireNo     int64
	Name         string
	Handle       string
	HomeSystemID int64
	HomeStarID   int64
	HomeOrbitID  int64
	HomePlanetID int64
}

// CreateEmpire creates a new empire.
func (q *Queries) CreateEmpire(ctx context.Context, arg CreateEmpireParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, createEmpire,
		arg.GameID,
		arg.EmpireNo,
		arg.Name,
		arg.Handle,
		arg.HomeSystemID,
		arg.HomeStarID,
		arg.HomeOrbitID,
		arg.HomePlanetID,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createGame = `-- name: CreateGame :one

INSERT INTO games (code, name, display_name)
VALUES (?1, ?2, ?3)
RETURNING id
`

type CreateGameParams struct {
	Code        string
	Name        string
	DisplayName string
}

//	Copyright (c) 2025 Michael D Henderson. All rights reserved.
//
// CreateGame creates a new game.
func (q *Queries) CreateGame(ctx context.Context, arg CreateGameParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, createGame, arg.Code, arg.Name, arg.DisplayName)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createOrbit = `-- name: CreateOrbit :one
INSERT INTO orbits (star_id, orbit_no, kind, scarcity)
VALUES (?1, ?2, ?3, ?4)
RETURNING id
`

type CreateOrbitParams struct {
	StarID   int64
	OrbitNo  int64
	Kind     string
	Scarcity int64
}

// CreateOrbit creates a new orbit.
func (q *Queries) CreateOrbit(ctx context.Context, arg CreateOrbitParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, createOrbit,
		arg.StarID,
		arg.OrbitNo,
		arg.Kind,
		arg.Scarcity,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createPlanet = `-- name: CreatePlanet :one
INSERT INTO planets (orbit_id, kind, scarcity, habitability)
VALUES (?1, ?2, ?3, ?4)
RETURNING id
`

type CreatePlanetParams struct {
	OrbitID      int64
	Kind         string
	Scarcity     int64
	Habitability int64
}

// CreatePlanet creates a new planet.
func (q *Queries) CreatePlanet(ctx context.Context, arg CreatePlanetParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, createPlanet,
		arg.OrbitID,
		arg.Kind,
		arg.Scarcity,
		arg.Habitability,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createSorC = `-- name: CreateSorC :one
INSERT INTO sorcs (empire_id, kind)
VALUES (?1, ?2)
RETURNING id
`

type CreateSorCParams struct {
	EmpireID int64
	Kind     string
}

// CreateSorC creates a new ship or colony.
func (q *Queries) CreateSorC(ctx context.Context, arg CreateSorCParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, createSorC, arg.EmpireID, arg.Kind)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createSorCDetails = `-- name: CreateSorCDetails :one
INSERT INTO sorc_details (sorc_id, turn_no, tech_level, name, uem_qty, uem_pay, usk_qty, usk_pay, pro_qty, pro_pay,
                          sld_qty, sld_pay, cnw_qty, spy_qty, rations, birth_rate, death_rate, sol, orbit_id,
                          is_on_surface)
VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9, ?10, ?11,
        ?12, ?13, ?14, ?15, ?16, ?17, ?18, ?19, ?20)
RETURNING id
`

type CreateSorCDetailsParams struct {
	SorcID      int64
	TurnNo      int64
	TechLevel   int64
	Name        string
	UemQty      int64
	UemPay      float64
	UskQty      int64
	UskPay      float64
	ProQty      int64
	ProPay      float64
	SldQty      int64
	SldPay      float64
	CnwQty      int64
	SpyQty      int64
	Rations     float64
	BirthRate   float64
	DeathRate   float64
	Sol         float64
	OrbitID     int64
	IsOnSurface int64
}

// CreateSorCDetails creates a new ship or colony details entry.
func (q *Queries) CreateSorCDetails(ctx context.Context, arg CreateSorCDetailsParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, createSorCDetails,
		arg.SorcID,
		arg.TurnNo,
		arg.TechLevel,
		arg.Name,
		arg.UemQty,
		arg.UemPay,
		arg.UskQty,
		arg.UskPay,
		arg.ProQty,
		arg.ProPay,
		arg.SldQty,
		arg.SldPay,
		arg.CnwQty,
		arg.SpyQty,
		arg.Rations,
		arg.BirthRate,
		arg.DeathRate,
		arg.Sol,
		arg.OrbitID,
		arg.IsOnSurface,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createSorCInfrastructure = `-- name: CreateSorCInfrastructure :exec
INSERT INTO sorc_infrastructure (sorc_detail_id, kind, tech_level, qty)
VALUES (?1, ?2, ?3, ?4)
`

type CreateSorCInfrastructureParams struct {
	SorcID    int64
	Kind      string
	TechLevel int64
	Qty       int64
}

// CreateSorCInfrastructure creates a new ship or colony infrastructure entry.
func (q *Queries) CreateSorCInfrastructure(ctx context.Context, arg CreateSorCInfrastructureParams) error {
	_, err := q.db.ExecContext(ctx, createSorCInfrastructure,
		arg.SorcID,
		arg.Kind,
		arg.TechLevel,
		arg.Qty,
	)
	return err
}

const createSorCInventory = `-- name: CreateSorCInventory :exec
INSERT INTO sorc_inventory (sorc_detail_id, kind, tech_level, qty_assembled, qty_stored)
VALUES (?1, ?2, ?3, ?4, ?5)
`

type CreateSorCInventoryParams struct {
	SorcID       int64
	Kind         string
	TechLevel    int64
	QtyAssembled int64
	QtyStored    int64
}

// CreateSorCInventory creates a new ship or colony inventory entry.
func (q *Queries) CreateSorCInventory(ctx context.Context, arg CreateSorCInventoryParams) error {
	_, err := q.db.ExecContext(ctx, createSorCInventory,
		arg.SorcID,
		arg.Kind,
		arg.TechLevel,
		arg.QtyAssembled,
		arg.QtyStored,
	)
	return err
}

const createSorCSuperstructure = `-- name: CreateSorCSuperstructure :exec
INSERT INTO sorc_superstructure (sorc_detail_id, kind, tech_level, qty)
VALUES (?1, ?2, ?3, ?4)
`

type CreateSorCSuperstructureParams struct {
	SorcID    int64
	Kind      string
	TechLevel int64
	Qty       int64
}

// CreateSorCSuperstructure creates a new ship or colony infrastructure entry.
func (q *Queries) CreateSorCSuperstructure(ctx context.Context, arg CreateSorCSuperstructureParams) error {
	_, err := q.db.ExecContext(ctx, createSorCSuperstructure,
		arg.SorcID,
		arg.Kind,
		arg.TechLevel,
		arg.Qty,
	)
	return err
}

const createStar = `-- name: CreateStar :one
INSERT INTO stars (system_id, sequence, scarcity)
VALUES (?1, ?2, ?3)
RETURNING id
`

type CreateStarParams struct {
	SystemID int64
	Sequence string
	Scarcity int64
}

// CreateStar creates a new star in an existing system.
func (q *Queries) CreateStar(ctx context.Context, arg CreateStarParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, createStar, arg.SystemID, arg.Sequence, arg.Scarcity)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createSystem = `-- name: CreateSystem :one
INSERT INTO systems (game_id, x, y, z, scarcity)
VALUES (?1, ?2, ?3, ?4, ?5)
RETURNING id
`

type CreateSystemParams struct {
	GameID   int64
	X        int64
	Y        int64
	Z        int64
	Scarcity int64
}

// CreateSystem creates a new system.
func (q *Queries) CreateSystem(ctx context.Context, arg CreateSystemParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, createSystem,
		arg.GameID,
		arg.X,
		arg.Y,
		arg.Z,
		arg.Scarcity,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createSystemDistance = `-- name: CreateSystemDistance :exec
INSERT INTO system_distances (from_system_id, to_system_id, distance)
VALUES (?1, ?2, ?3)
`

type CreateSystemDistanceParams struct {
	FromSystemID int64
	ToSystemID   int64
	Distance     int64
}

// CreateSystemDistance inserts the distance between two systems.
func (q *Queries) CreateSystemDistance(ctx context.Context, arg CreateSystemDistanceParams) error {
	_, err := q.db.ExecContext(ctx, createSystemDistance, arg.FromSystemID, arg.ToSystemID, arg.Distance)
	return err
}

const deleteEmptyDeposits = `-- name: DeleteEmptyDeposits :exec
DELETE
FROM deposits
WHERE kind = 'none'
`

// DeleteEmptyOrbits deletes all orbits with no planets.
func (q *Queries) DeleteEmptyDeposits(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteEmptyDeposits)
	return err
}

const deleteEmptyOrbits = `-- name: DeleteEmptyOrbits :exec
DELETE
FROM orbits
WHERE kind = 'empty'
`

// DeleteEmptyOrbits deletes all orbits with no planets.
func (q *Queries) DeleteEmptyOrbits(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteEmptyOrbits)
	return err
}

const deleteGame = `-- name: DeleteGame :exec
DELETE
FROM games
WHERE code = ?1
`

// DeleteGame deletes an existing game
func (q *Queries) DeleteGame(ctx context.Context, code string) error {
	_, err := q.db.ExecContext(ctx, deleteGame, code)
	return err
}

const getCurrentGameTurn = `-- name: GetCurrentGameTurn :one
SELECT current_turn
FROM games
WHERE id = ?1
`

// GetCurrentGameTurn gets the current game turn.
func (q *Queries) GetCurrentGameTurn(ctx context.Context, gameID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, getCurrentGameTurn, gameID)
	var current_turn int64
	err := row.Scan(&current_turn)
	return current_turn, err
}

const readClusterMap = `-- name: ReadClusterMap :many
SELECT systems.id      AS id,
       systems.x       as x,
       systems.y       as y,
       systems.z       as z,
       count(stars.id) AS number_of_stars
FROM games
         LEFT JOIN systems on games.id = systems.game_id
         LEFT JOIN stars on systems.id = stars.system_id
WHERE games.code = ?1
GROUP BY systems.id, systems.x, systems.y, systems.z
ORDER BY systems.id
`

type ReadClusterMapRow struct {
	ID            sql.NullInt64
	X             sql.NullInt64
	Y             sql.NullInt64
	Z             sql.NullInt64
	NumberOfStars int64
}

// ReadClusterMap reads the cluster map.
func (q *Queries) ReadClusterMap(ctx context.Context, gameCode string) ([]ReadClusterMapRow, error) {
	rows, err := q.db.QueryContext(ctx, readClusterMap, gameCode)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ReadClusterMapRow
	for rows.Next() {
		var i ReadClusterMapRow
		if err := rows.Scan(
			&i.ID,
			&i.X,
			&i.Y,
			&i.Z,
			&i.NumberOfStars,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const readEmpireAllColoniesForTurn = `-- name: ReadEmpireAllColoniesForTurn :many
SELECT sorc_id,
       sorcs.kind,
       tech_level,
       name,
       uem_qty,
       uem_pay,
       usk_qty,
       usk_pay,
       pro_qty,
       pro_pay,
       sld_qty,
       sld_pay,
       cnw_qty,
       spy_qty,
       rations,
       birth_rate,
       death_rate,
       sol,
       systems.x,
       systems.y,
       systems.z,
       stars.sequence as suffix,
       orbits.orbit_no,
       is_on_surface
FROM sorcs
         LEFT JOIN sorc_details ON sorcs.id = sorc_details.sorc_id AND sorc_details.turn_no = ?1
         LEFT JOIN orbits ON orbits.id = sorc_details.orbit_id
         LEFT JOIN stars ON stars.id = orbits.star_id
         LEFT JOIN systems ON systems.id = stars.system_id
WHERE sorcs.empire_id = ?2
  AND sorcs.kind in ('open-colony', 'enclosed-colony', 'orbital-colony')
ORDER BY sorcs.id, sorcs.kind
`

type ReadEmpireAllColoniesForTurnParams struct {
	TurnNo   int64
	EmpireID int64
}

type ReadEmpireAllColoniesForTurnRow struct {
	SorcID      sql.NullInt64
	Kind        string
	TechLevel   sql.NullInt64
	Name        sql.NullString
	UemQty      sql.NullInt64
	UemPay      sql.NullFloat64
	UskQty      sql.NullInt64
	UskPay      sql.NullFloat64
	ProQty      sql.NullInt64
	ProPay      sql.NullFloat64
	SldQty      sql.NullInt64
	SldPay      sql.NullFloat64
	CnwQty      sql.NullInt64
	SpyQty      sql.NullInt64
	Rations     sql.NullFloat64
	BirthRate   sql.NullFloat64
	DeathRate   sql.NullFloat64
	Sol         sql.NullFloat64
	X           sql.NullInt64
	Y           sql.NullInt64
	Z           sql.NullInt64
	Suffix      sql.NullString
	OrbitNo     sql.NullInt64
	IsOnSurface sql.NullInt64
}

// ReadEmpireAllColoniesForTurn reads the colonies for a given empire and turn in a game.
func (q *Queries) ReadEmpireAllColoniesForTurn(ctx context.Context, arg ReadEmpireAllColoniesForTurnParams) ([]ReadEmpireAllColoniesForTurnRow, error) {
	rows, err := q.db.QueryContext(ctx, readEmpireAllColoniesForTurn, arg.TurnNo, arg.EmpireID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ReadEmpireAllColoniesForTurnRow
	for rows.Next() {
		var i ReadEmpireAllColoniesForTurnRow
		if err := rows.Scan(
			&i.SorcID,
			&i.Kind,
			&i.TechLevel,
			&i.Name,
			&i.UemQty,
			&i.UemPay,
			&i.UskQty,
			&i.UskPay,
			&i.ProQty,
			&i.ProPay,
			&i.SldQty,
			&i.SldPay,
			&i.CnwQty,
			&i.SpyQty,
			&i.Rations,
			&i.BirthRate,
			&i.DeathRate,
			&i.Sol,
			&i.X,
			&i.Y,
			&i.Z,
			&i.Suffix,
			&i.OrbitNo,
			&i.IsOnSurface,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const readGameByCode = `-- name: ReadGameByCode :one
SELECT id,
       code,
       name,
       display_name,
       current_turn,
       last_empire_no,
       home_system_id,
       home_star_id,
       home_orbit_id,
       home_planet_id
FROM games
WHERE code = ?1
`

type ReadGameByCodeRow struct {
	ID           int64
	Code         string
	Name         string
	DisplayName  string
	CurrentTurn  int64
	LastEmpireNo int64
	HomeSystemID int64
	HomeStarID   int64
	HomeOrbitID  int64
	HomePlanetID int64
}

// ReadGameByCode gets a game by its code.
func (q *Queries) ReadGameByCode(ctx context.Context, code string) (ReadGameByCodeRow, error) {
	row := q.db.QueryRowContext(ctx, readGameByCode, code)
	var i ReadGameByCodeRow
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Name,
		&i.DisplayName,
		&i.CurrentTurn,
		&i.LastEmpireNo,
		&i.HomeSystemID,
		&i.HomeStarID,
		&i.HomeOrbitID,
		&i.HomePlanetID,
	)
	return i, err
}

const readGameEmpire = `-- name: ReadGameEmpire :one
SELECT game_id, id AS empire_id, empire_no
FROM empires
WHERE empire_no = ?1
  AND game_id = (SELECT id FROM games WHERE code = ?2)
`

type ReadGameEmpireParams struct {
	EmpireNo int64
	GameCode string
}

type ReadGameEmpireRow struct {
	GameID   int64
	EmpireID int64
	EmpireNo int64
}

// ReadGameEmpire returns the data for a single empire in a game.
func (q *Queries) ReadGameEmpire(ctx context.Context, arg ReadGameEmpireParams) (ReadGameEmpireRow, error) {
	row := q.db.QueryRowContext(ctx, readGameEmpire, arg.EmpireNo, arg.GameCode)
	var i ReadGameEmpireRow
	err := row.Scan(&i.GameID, &i.EmpireID, &i.EmpireNo)
	return i, err
}

const readGameEmpires = `-- name: ReadGameEmpires :many
SELECT game_id, id AS empire_id, empire_no
FROM empires
WHERE game_id = (SELECT id FROM games WHERE code = ?1)
`

type ReadGameEmpiresRow struct {
	GameID   int64
	EmpireID int64
	EmpireNo int64
}

// ReadGameEmpires returns the data for all empires in a game.
func (q *Queries) ReadGameEmpires(ctx context.Context, gameCode string) ([]ReadGameEmpiresRow, error) {
	rows, err := q.db.QueryContext(ctx, readGameEmpires, gameCode)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ReadGameEmpiresRow
	for rows.Next() {
		var i ReadGameEmpiresRow
		if err := rows.Scan(&i.GameID, &i.EmpireID, &i.EmpireNo); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const readNextEmpireNumber = `-- name: ReadNextEmpireNumber :one
UPDATE games
SET last_empire_no = last_empire_no + 1
WHERE id = ?1
RETURNING last_empire_no as next_empire_no
`

// ReadNextEmpireNumber reads the next empire number.
func (q *Queries) ReadNextEmpireNumber(ctx context.Context, gameID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, readNextEmpireNumber, gameID)
	var last_empire_no int64
	err := row.Scan(&last_empire_no)
	return last_empire_no, err
}

const updateGameEmpireCounter = `-- name: UpdateGameEmpireCounter :exec
UPDATE games
SET last_empire_no = ?1
WHERE id = ?2
`

type UpdateGameEmpireCounterParams struct {
	EmpireNo int64
	GameID   int64
}

// UpdateGameEmpireCounter updates the last empire number in the games table.
func (q *Queries) UpdateGameEmpireCounter(ctx context.Context, arg UpdateGameEmpireCounterParams) error {
	_, err := q.db.ExecContext(ctx, updateGameEmpireCounter, arg.EmpireNo, arg.GameID)
	return err
}

const updateGameEmpireMetadata = `-- name: UpdateGameEmpireMetadata :exec
UPDATE games
SET last_empire_no = ?1,
    home_system_id = ?2,
    home_star_id   = ?3,
    home_orbit_id  = ?4,
    home_planet_id = ?5
WHERE id = ?6
`

type UpdateGameEmpireMetadataParams struct {
	EmpireNo     int64
	HomeSystemID int64
	HomeStarID   int64
	HomeOrbitID  int64
	HomePlanetID int64
	GameID       int64
}

// UpdateGameEmpireMetadata updates the empire metadata in the games table.
func (q *Queries) UpdateGameEmpireMetadata(ctx context.Context, arg UpdateGameEmpireMetadataParams) error {
	_, err := q.db.ExecContext(ctx, updateGameEmpireMetadata,
		arg.EmpireNo,
		arg.HomeSystemID,
		arg.HomeStarID,
		arg.HomeOrbitID,
		arg.HomePlanetID,
		arg.GameID,
	)
	return err
}

const updateGameTurn = `-- name: UpdateGameTurn :exec
UPDATE games
SET current_turn = ?1
WHERE id = ?2
`

type UpdateGameTurnParams struct {
	TurnNumber int64
	GameID     int64
}

// UpdateGameTurn increments the game turn number.
func (q *Queries) UpdateGameTurn(ctx context.Context, arg UpdateGameTurnParams) error {
	_, err := q.db.ExecContext(ctx, updateGameTurn, arg.TurnNumber, arg.GameID)
	return err
}
