// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: stars.sql

package sqlc

import (
	"context"
	"database/sql"
)

const readAllStars = `-- name: ReadAllStars :many

SELECT systems.id      AS system_id,
       stars.id        as star_id,
       stars.sequence  as sequence,
       systems.x       as x,
       systems.y       as y,
       systems.z       as z,
       count(stars.id) AS number_of_stars
FROM games
         LEFT JOIN systems on games.id = systems.game_id
         LEFT JOIN stars on systems.id = stars.system_id
WHERE games.id = ?1
ORDER BY systems.id
`

type ReadAllStarsRow struct {
	SystemID      sql.NullInt64
	StarID        sql.NullInt64
	Sequence      sql.NullString
	X             sql.NullInt64
	Y             sql.NullInt64
	Z             sql.NullInt64
	NumberOfStars int64
}

//	Copyright (c) 2025 Michael D Henderson. All rights reserved.
//
// ReadAllStars reads the stars data for a game.
func (q *Queries) ReadAllStars(ctx context.Context, gameID int64) ([]ReadAllStarsRow, error) {
	rows, err := q.db.QueryContext(ctx, readAllStars, gameID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ReadAllStarsRow
	for rows.Next() {
		var i ReadAllStarsRow
		if err := rows.Scan(
			&i.SystemID,
			&i.StarID,
			&i.Sequence,
			&i.X,
			&i.Y,
			&i.Z,
			&i.NumberOfStars,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const readStarSurvey = `-- name: ReadStarSurvey :many
SELECT systems.id                  AS system_id,
       stars.id                    as star_id,
       orbits.id                   as orbit_id,
       planets.id                  as planet_id,
       systems.x                   as x,
       systems.y                   as y,
       systems.z                   as z,
       stars.sequence              as sequence,
       orbits.kind                 as orbit_kind,
       orbits.orbit_no             as orbit_no,
       planets.kind                as planet_kind,
       deposits.kind               as deposit_kind,
       sum(deposits.remaining_qty) as quantity
FROM games,
     systems,
     stars,
     orbits,
     planets,
     deposits
WHERE stars.id = ?1
  AND stars.system_id = systems.id
  AND systems.game_id = games.id
  AND orbits.star_id = stars.id
  AND planets.orbit_id = orbits.id
  AND deposits.planet_id = planets.id
GROUP BY systems.id, stars.id, orbits.id, planets.id, deposits.kind
ORDER BY systems.id, stars.id, orbits.id, planets.id, deposits.kind
`

type ReadStarSurveyRow struct {
	SystemID    int64
	StarID      int64
	OrbitID     int64
	PlanetID    int64
	X           int64
	Y           int64
	Z           int64
	Sequence    string
	OrbitKind   int64
	OrbitNo     int64
	PlanetKind  int64
	DepositKind int64
	Quantity    sql.NullFloat64
}

// ReadStarSurvey reads the star survey data for a game.
func (q *Queries) ReadStarSurvey(ctx context.Context, starID int64) ([]ReadStarSurveyRow, error) {
	rows, err := q.db.QueryContext(ctx, readStarSurvey, starID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ReadStarSurveyRow
	for rows.Next() {
		var i ReadStarSurveyRow
		if err := rows.Scan(
			&i.SystemID,
			&i.StarID,
			&i.OrbitID,
			&i.PlanetID,
			&i.X,
			&i.Y,
			&i.Z,
			&i.Sequence,
			&i.OrbitKind,
			&i.OrbitNo,
			&i.PlanetKind,
			&i.DepositKind,
			&i.Quantity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const readStarsInSystem = `-- name: ReadStarsInSystem :many
SELECT stars.id
FROM systems,
     stars
WHERE systems.id = ?1
  AND stars.system_id = systems.id
ORDER BY systems.id, stars.sequence
`

// ReadStarsInSystem returns a list of stars in a system.
func (q *Queries) ReadStarsInSystem(ctx context.Context, systemID int64) ([]int64, error) {
	rows, err := q.db.QueryContext(ctx, readStarsInSystem, systemID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var id int64
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
