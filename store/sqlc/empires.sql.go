// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: empires.sql

package sqlc

import (
	"context"
)

const createEmpire = `-- name: CreateEmpire :exec
insert into empire (empire_id,
                    empire_name,
                    username,
                    email,
                    home_system_id,
                    home_star_id,
                    home_orbit_id)
values (?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7)
`

type CreateEmpireParams struct {
	EmpireID     int64
	EmpireName   string
	Username     string
	Email        string
	HomeSystemID int64
	HomeStarID   int64
	HomeOrbitID  int64
}

// CreateEmpire creates a new empire.
func (q *Queries) CreateEmpire(ctx context.Context, arg CreateEmpireParams) error {
	_, err := q.db.ExecContext(ctx, createEmpire,
		arg.EmpireID,
		arg.EmpireName,
		arg.Username,
		arg.Email,
		arg.HomeSystemID,
		arg.HomeStarID,
		arg.HomeOrbitID,
	)
	return err
}

const createInactiveEmpires = `-- name: CreateInactiveEmpires :exec
insert into empires (id, is_active)
values (?1, 0)
`

// CreateInactiveEmpires creates a new inactive empire.
func (q *Queries) CreateInactiveEmpires(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, createInactiveEmpires, id)
	return err
}

const isEmpireActive = `-- name: IsEmpireActive :one
select is_active
from empires
where id = ?1
`

// IsEmpireActive checks if an empire is active.
func (q *Queries) IsEmpireActive(ctx context.Context, empireID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, isEmpireActive, empireID)
	var is_active int64
	err := row.Scan(&is_active)
	return is_active, err
}

const readActiveEmpireCount = `-- name: ReadActiveEmpireCount :one
select count(id)
from empires
where is_active = 1
`

// ReadActiveEmpireCount returns the number of active empires.
func (q *Queries) ReadActiveEmpireCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, readActiveEmpireCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const readActiveEmpires = `-- name: ReadActiveEmpires :many
select id as empire_id
from empires
where is_active = 1
order by id
`

// ReadActiveEmpires returns the data for all active empires in a game.
func (q *Queries) ReadActiveEmpires(ctx context.Context) ([]int64, error) {
	rows, err := q.db.QueryContext(ctx, readActiveEmpires)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var empire_id int64
		if err := rows.Scan(&empire_id); err != nil {
			return nil, err
		}
		items = append(items, empire_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const readEmpireByID = `-- name: ReadEmpireByID :one
select games.code         as game_code,
       games.name         as game_name,
       games.display_name as game_display_name,
       games.current_turn as game_current_turn,
       empire.empire_id,
       empire.empire_name,
       empire.username,
       empire.email,
       empire.home_system_id,
       empire.home_star_id,
       empire.home_orbit_id
from games,
     empires,
     empire
where empires.id = ?1
  and empire.empire_id = empires.id
  and is_active = 1
`

type ReadEmpireByIDRow struct {
	GameCode        string
	GameName        string
	GameDisplayName string
	GameCurrentTurn int64
	EmpireID        int64
	EmpireName      string
	Username        string
	Email           string
	HomeSystemID    int64
	HomeStarID      int64
	HomeOrbitID     int64
}

// ReadEmpireByID reads an empire by its id.
// This should only be used by admins. Regular users should use ReadEmpireByUser.
func (q *Queries) ReadEmpireByID(ctx context.Context, empireID int64) (ReadEmpireByIDRow, error) {
	row := q.db.QueryRowContext(ctx, readEmpireByID, empireID)
	var i ReadEmpireByIDRow
	err := row.Scan(
		&i.GameCode,
		&i.GameName,
		&i.GameDisplayName,
		&i.GameCurrentTurn,
		&i.EmpireID,
		&i.EmpireName,
		&i.Username,
		&i.Email,
		&i.HomeSystemID,
		&i.HomeStarID,
		&i.HomeOrbitID,
	)
	return i, err
}

const readNextEmpireNumber = `-- name: ReadNextEmpireNumber :one
select min(id) + 0 as empire_id
from empires
where is_active = 0
`

// ReadNextEmpireNumber reads the next empire number in a game.
func (q *Queries) ReadNextEmpireNumber(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, readNextEmpireNumber)
	var empire_id int64
	err := row.Scan(&empire_id)
	return empire_id, err
}

const updateEmpireStatus = `-- name: UpdateEmpireStatus :exec
update empires
set is_active = ?1
where id = ?2
`

type UpdateEmpireStatusParams struct {
	IsActive int64
	EmpireID int64
}

// UpdateEmpireStatus updates the status of an empire.
func (q *Queries) UpdateEmpireStatus(ctx context.Context, arg UpdateEmpireStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateEmpireStatus, arg.IsActive, arg.EmpireID)
	return err
}
